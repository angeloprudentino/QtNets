<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- canvas3d.cpp -->
  <title>Canvas3D QML Type | Qt Canvas 3D 5.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-7">Qt 5.7</a></td><td ><a href="qtcanvas3d-index.html">Qt Canvas 3D</a></td><td ><a href="qtcanvas3d-qmlmodule.html">QML Types</a></td><td >Canvas3D QML Type</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.7.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#properties">Properties</a></li>
<li class="level1"><a href="#signals">Signals</a></li>
<li class="level1"><a href="#methods">Methods</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">Canvas3D QML Type</h1>
<span class="subtitle"></span>
<!-- $$$Canvas3D-brief -->
<p>Canvas that provides a 3D rendering context. <a href="#details">More...</a></p>
<!-- @@@Canvas3D -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> Import Statement:</td><td class="memItemRight bottomAlign"> import QtCanvas3D 1.1</td></tr><tr><td class="memItemLeft rightAlign topAlign"> Since:</td><td class="memItemRight bottomAlign">  QtCanvas3D 1.0</td></tr></table></div><ul>
<li><a href="qml-qtcanvas3d-canvas3d-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="properties"></a>
<h2 id="properties">Properties</h2>
<ul>
<li class="fn"><b><b><a href="qml-qtcanvas3d-canvas3d.html#context-prop">context</a></b></b> : Context3D</li>
<li class="fn"><b><b><a href="qml-qtcanvas3d-canvas3d.html#devicePixelRatio-prop">devicePixelRatio</a></b></b> : float</li>
<li class="fn"><b><b><a href="qml-qtcanvas3d-canvas3d.html#fps-prop">fps</a></b></b> : int</li>
<li class="fn"><b><b><a href="qml-qtcanvas3d-canvas3d.html#pixelSize-prop">pixelSize</a></b></b> : size</li>
<li class="fn"><b><b><a href="qml-qtcanvas3d-canvas3d.html#renderOnDemand-prop">renderOnDemand</a></b></b> : bool</li>
<li class="fn"><b><b><a href="qml-qtcanvas3d-canvas3d.html#renderTarget-prop">renderTarget</a></b></b> : RenderTarget</li>
</ul>
<a name="signals"></a>
<h2 id="signals">Signals</h2>
<ul>
<li class="fn">void <b><b><a href="qml-qtcanvas3d-canvas3d.html#contextLost-signal">contextLost</a></b></b>()</li>
<li class="fn">void <b><b><a href="qml-qtcanvas3d-canvas3d.html#contextRestored-signal">contextRestored</a></b></b>()</li>
<li class="fn">void <b><b><a href="qml-qtcanvas3d-canvas3d.html#initializeGL-signal">initializeGL</a></b></b>()</li>
<li class="fn">void <b><b><a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">paintGL</a></b></b>()</li>
</ul>
<a name="methods"></a>
<h2 id="methods">Methods</h2>
<ul>
<li class="fn">int <b><b><a href="qml-qtcanvas3d-canvas3d.html#frameSetupTimeMs-method">frameSetupTimeMs</a></b></b>()</li>
<li class="fn">int <b><b><a href="qml-qtcanvas3d-canvas3d.html#frameTimeMs-method">frameTimeMs</a></b></b>()</li>
<li class="fn">Context3D <b><b><a href="qml-qtcanvas3d-canvas3d.html#getContext-method-1">getContext</a></b></b>(string <i>type</i>, Canvas3DContextAttributes <i>options</i>)</li>
<li class="fn">Context3D <b><b><a href="qml-qtcanvas3d-canvas3d.html#getContext-method">getContext</a></b></b>(string <i>type</i>)</li>
<li class="fn">void <b><b><a href="qml-qtcanvas3d-canvas3d.html#requestRender-method">requestRender</a></b></b>()</li>
</ul>
<!-- $$$Canvas3D-description -->
<a name="details"></a>
<h2 id="details">Detailed Description</h2>
</p>
<p>The <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> is a QML element that, when placed in your Qt Quick 2 scene, allows you to get a 3D rendering context and call 3D rendering API calls through that context object. Use of the rendering API requires knowledge of OpenGL-like rendering APIs.</p>
<p>There are two functions that are called by the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> implementation:</p>
<ul>
<li><a href="qml-qtcanvas3d-canvas3d.html#initializeGL-signal">initializeGL</a> is emitted before the first frame is rendered, and usually during that you get the 3D context and initialize resources to be used later on during the rendering cycle.</li>
<li><a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">paintGL</a> is emitted for each frame to be rendered, and usually during that you submit 3D rendering calls to draw whatever 3D content you want to be displayed.</li>
</ul>
<p><b>See also </b><a href="qml-qtcanvas3d-context3d.html">Context3D</a>.</p>
<!-- @@@Canvas3D -->
<h2>Property Documentation</h2>
<!-- $$$context -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="context-prop">
<td class="tblQmlPropNode"><p>
<a name="context-prop"></a><span class="name">context</span> : <span class="type"><a href="qml-qtcanvas3d-context3d.html">Context3D</a></span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>This property can be used to access the context created with <a href="qml-qtcanvas3d-canvas3d.html#getContext-method">getContext()</a> method.</p>
<p><b>See also </b><a href="qml-qtcanvas3d-canvas3d.html#getContext-method">getContext()</a>.</p>
</div></div><!-- @@@context -->
<br/>
<!-- $$$devicePixelRatio -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="devicePixelRatio-prop">
<td class="tblQmlPropNode"><p>
<a name="devicePixelRatio-prop"></a><span class="name">devicePixelRatio</span> : <span class="type">float</span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Specifies the ratio between logical pixels (used by the Qt Quick) and actual physical on-screen pixels (used by the 3D rendering).</p>
</div></div><!-- @@@devicePixelRatio -->
<br/>
<!-- $$$fps -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="fps-prop">
<td class="tblQmlPropNode"><p>
<a name="fps-prop"></a><span class="name">fps</span> : <span class="type">int</span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>This property specifies the current number of frames rendered per second. The value is recalculated every 500 ms, as long as any rendering is done.</p>
<p><b>Note: </b>This property only gets updated after a <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> frame is rendered, so if no frames are being drawn, this property value won't change. It is also based on the number of <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> frames actually rendered since the value was last updated, so it may not accurately reflect the actual rendering performance when If <a href="qml-qtcanvas3d-canvas3d.html#renderOnDemand-prop">Canvas3D.renderOnDemand</a> property is <code>true</code>.</p><p><b>See also </b><a href="qml-qtcanvas3d-canvas3d.html#frameTimeMs-method">frameTimeMs</a>.</p>
</div></div><!-- @@@fps -->
<br/>
<!-- $$$pixelSize -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="pixelSize-prop">
<td class="tblQmlPropNode"><p>
<a name="pixelSize-prop"></a><span class="name">pixelSize</span> : <span class="type">size</span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Specifies the size of the render target surface in physical on-screen pixels used by the 3D rendering.</p>
</div></div><!-- @@@pixelSize -->
<br/>
<!-- $$$renderOnDemand -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="renderOnDemand-prop">
<td class="tblQmlPropNode"><p>
<a name="renderOnDemand-prop"></a><span class="name">renderOnDemand</span> : <span class="type">bool</span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>If the value is <code>false</code>, the render loop runs constantly and <a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">Canvas3D.paintGL()</a> signal is emitted once per frame. If the value is <code>true</code>, <a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">Canvas3D.paintGL()</a> is only emitted when <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> content needs to be re-rendered because a geometry change or some other event affecting the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> content occurred. The application can also request a render using <a href="qml-qtcanvas3d-canvas3d.html#requestRender-method">Canvas3D.requestRender()</a> method.</p>
</div></div><!-- @@@renderOnDemand -->
<br/>
<!-- $$$renderTarget -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="renderTarget-prop">
<td class="tblQmlPropNode"><p>
<a name="renderTarget-prop"></a><span class="name">renderTarget</span> : <span class="type">RenderTarget</span></p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Specifies how the rendering should be done.</p>
<ul>
<li><code>Canvas3D.RenderTargetOffscreenBuffer</code> indicates rendering is done into an offscreen buffer and the finished texture is used for the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> item. This is the default target.</li>
<li><code>Canvas3D.RenderTargetBackground</code> indicates the rendering is done to the background of the Qt Quick scene, in response to <a href="../qtquick/qquickwindow.html#beforeRendering">QQuickWindow::beforeRendering()</a> signal.</li>
<li><code>Canvas3D.RenderTargetForeground</code> indicates the rendering is done to the foreground of the Qt Quick scene, in response to <a href="../qtquick/qquickwindow.html#afterRendering">QQuickWindow::afterRendering()</a> signal.</li>
</ul>
<p><code>Canvas3D.RenderTargetBackground</code> and <code>Canvas3D.RenderTargetForeground</code> targets render directly to the same framebuffer the rest of the Qt Quick scene uses. This will improve performance on platforms that are fill-rate limited, but using these targets imposes several limitations on the usage of <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a>:</p>
<ul>
<li>Synchronous <a href="qml-qtcanvas3d-context3d.html">Context3D</a> commands are not supported outside <a href="qml-qtcanvas3d-canvas3d.html#initializeGL-signal">Canvas3D.initializeGL()</a> signal handler when rendering directly to Qt Quick scene framebuffer, as they cause portions of the command queue to be executed outside the normal frame render sequence, which interferes with the frame clearing logic. Using them will usually result in <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> content not rendering properly. A synchronous command is any <a href="qml-qtcanvas3d-context3d.html">Context3D</a> command that requires waiting for <a href="qml-qtcanvas3d-context3d.html">Context3D</a> command queue to finish executing before it returns, such as <a href="qml-qtcanvas3d-context3d.html#getError-method">Context3D.getError()</a>, <a href="qml-qtcanvas3d-context3d.html#finish-method">Context3D.finish()</a>, or <a href="qml-qtcanvas3d-context3d.html#readPixels-method">Context3D.readPixels()</a>. When in doubt, see the individual command documentation to see if that command is synchronous. If your application requires synchronous commands outside <a href="qml-qtcanvas3d-canvas3d.html#initializeGL-signal">Canvas3D.initializeGL()</a> signal handler, you should use <code>Canvas3D.RenderTargetOffscreenBuffer</code> render target.</li>
<li>Only <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> items that fill the entire window are supported. Note that you can still control the actual rendering area by using an appropriate viewport.</li>
<li>The default framebuffer is automatically cleared by <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> every time before the Qt Quick scene renders a frame, even if there are no <a href="qml-qtcanvas3d-context3d.html">Context3D</a> commands queued for that frame. This requires <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> to store the commands used to draw the previous frame in case the window is updated by some other component than <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> and use those commands to render the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> content for frames that do not have fresh content. Only commands issued inside <a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">Canvas3D.paintGL()</a> signal handler are stored this way. You need to make sure that the content of your <a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">Canvas3D.paintGL()</a> signal handler is implemented so that it is safe to execute its commands repeatedly. Mainly this means making sure you don't use any synchronous commands or commands that create new persistent OpenGL resources there.</li>
<li>Issuing <a href="qml-qtcanvas3d-context3d.html">Context3D</a> commands outside <a href="qml-qtcanvas3d-canvas3d.html#paintGL-signal">Canvas3D.paintGL()</a> and <a href="qml-qtcanvas3d-canvas3d.html#initializeGL-signal">Canvas3D.initializeGL()</a> signal handlers can in some cases cause unwanted flickering of <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> content, particularly if on-demand rendering is used. It is recommended to avoid issuing any <a href="qml-qtcanvas3d-context3d.html">Context3D</a> commands outside these two signal handlers.</li>
<li>When drawing to the foreground, you should never issue a <a href="qml-qtcanvas3d-context3d.html#clear-method">Context3D.clear(Context3D.GL_COLOR_BUFFER_BIT)</a> command targeting the default framebuffer, as that will clear all other Qt Quick items from the scene. Clearing depth and stencil buffers is allowed.</li>
<li>Antialiasing is only supported if the surface format of the window supports multisampling. You may need to specify the surface format of the window explicitly in your <code>main.cpp</code>.</li>
<li>You lose the ability to control the z-order of the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> item itself, as it is always drawn either behind or in front of all other Qt Quick items.</li>
<li>The context attributes given as <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a>.<a href="qml-qtcanvas3d-canvas3d.html#getContext-method">getContext()</a> parameters are ignored and the corresponding values of the Qt Quick context are used.</li>
<li>Drawing to the background or the foreground doesn't work when Qt Quick is using OpenGL core profile, as <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> requires either OpenGL 2.x compatibility or OpenGL ES2.</li>
</ul>
<p>This property can only be modified before the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> item has been rendered for the first time.</p>
</div></div><!-- @@@renderTarget -->
<br/>
<h2>Signal Documentation</h2>
<!-- $$$contextLost -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="contextLost-signal">
<td class="tblQmlFuncNode"><p>
<a name="contextLost-signal"></a><span class="type">void</span> <span class="name">contextLost</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Emitted when OpenGL context is lost. This happens whenever the parent window of the <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> is destroyed (or otherwise loses its context), or <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> is moved to a different window. Removing <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> from a window and adding it back to the same window doesn't cause context loss, as long as the window itself stays alive.</p>
<p>When context is lost, all objects created by <a href="qml-qtcanvas3d-context3d.html">Context3D</a> are invalidated.</p>
<p><b>See also </b><a href="qml-qtcanvas3d-canvas3d.html#contextRestored-signal">contextRestored</a>.</p>
</div></div><!-- @@@contextLost -->
<br/>
<!-- $$$contextRestored -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="contextRestored-signal">
<td class="tblQmlFuncNode"><p>
<a name="contextRestored-signal"></a><span class="type">void</span> <span class="name">contextRestored</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Emitted when OpenGL context is restored after a loss of context occurred. The <a href="qml-qtcanvas3d-context3d.html">Context3D</a> attached to the canvas needs to be reinitialized, so <a href="qml-qtcanvas3d-canvas3d.html#initializeGL-signal">initializeGL</a> is also emitted after this signal.</p>
<p><b>See also </b><a href="qml-qtcanvas3d-canvas3d.html#contextLost-signal">contextLost</a>.</p>
</div></div><!-- @@@contextRestored -->
<br/>
<!-- $$$initializeGL -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="initializeGL-signal">
<td class="tblQmlFuncNode"><p>
<a name="initializeGL-signal"></a><span class="type">void</span> <span class="name">initializeGL</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Emitted once when <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> is ready and OpenGL state initialization can be done by the client.</p>
</div></div><!-- @@@initializeGL -->
<br/>
<!-- $$$paintGL -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="paintGL-signal">
<td class="tblQmlFuncNode"><p>
<a name="paintGL-signal"></a><span class="type">void</span> <span class="name">paintGL</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Emitted each time a new frame should be drawn to <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a>. Driven by the Qt Quick scenegraph loop.</p>
</div></div><!-- @@@paintGL -->
<br/>
<h2>Method Documentation</h2>
<!-- $$$frameSetupTimeMs -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="frameSetupTimeMs-method">
<td class="tblQmlFuncNode"><p>
<a name="frameSetupTimeMs-method"></a><span class="type">int</span> <span class="name">frameSetupTimeMs</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>This method returns the number of milliseconds <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a> took to process the PaintGL signal for the previous frame. Before any frames have been rendered this method returns 0. This time doesn't include time spent on actual OpenGL rendering of the frame, nor the time the scene graph takes to present the frame to the screen. This value is updated after PaintGL signal handler returns.</p>
<p>This QML method was introduced in  QtCanvas3D 1.1.</p>
<p><b>See also </b><a href="qml-qtcanvas3d-canvas3d.html#fps-prop">fps</a> and <a href="qml-qtcanvas3d-canvas3d.html#frameTimeMs-method">frameTimeMs</a>.</p>
</div></div><!-- @@@frameSetupTimeMs -->
<br/>
<!-- $$$frameTimeMs -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="frameTimeMs-method">
<td class="tblQmlFuncNode"><p>
<a name="frameTimeMs-method"></a><span class="type">int</span> <span class="name">frameTimeMs</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>This method returns the number of milliseconds the renderer took to process the OpenGL portion of the rendering for the previous frame. Before any frames have been rendered this method returns 0. This time is measured from the point OpenGL commands are transferred to render thread to the time glFinish() returns, so it doesn't include the time spent parsing JavaScript, nor the time the scene graph takes to present the frame to the screen. This value is updated for the previous frame when the next frame OpenGL command transfer is done.</p>
<p><b>See also </b><a href="qml-qtcanvas3d-canvas3d.html#fps-prop">fps</a> and <a href="qml-qtcanvas3d-canvas3d.html#frameSetupTimeMs-method">frameSetupTimeMs</a>.</p>
</div></div><!-- @@@frameTimeMs -->
<br/>
<!-- $$$getContext -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="getContext-method-1">
<td class="tblQmlFuncNode"><p>
<a name="getContext-method-1"></a><span class="type"><a href="qml-qtcanvas3d-context3d.html">Context3D</a></span> <span class="name">getContext</span>(<span class="type">string</span> <i>type</i>, <span class="type"><a href="qml-qtcanvas3d-canvas3dcontextattributes.html">Canvas3DContextAttributes</a></span> <i>options</i>)</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Returns the 3D rendering context that allows 3D rendering calls to be made. The <i>type</i> parameter is ignored for now, but a string is expected to be given. If <a href="qml-qtcanvas3d-canvas3d.html">Canvas3D</a>.<a href="qml-qtcanvas3d-canvas3d.html#renderTarget-prop">renderTarget</a> property value is either <code>Canvas3D.RenderTargetBackground</code> or <code>Canvas3D.RenderTargetForeground</code>, the <i>options</i> parameter is also ignored, the context attributes of the Qt Quick context are used, and the <a href="qml-qtcanvas3d-canvas3dcontextattributes.html#preserveDrawingBuffer-prop">Canvas3DContextAttributes.preserveDrawingBuffer</a> property is forced to <code>false</code>. The <i>options</i> parameter is only parsed when the first call to <a href="qml-qtcanvas3d-canvas3d.html#getContext-method">getContext()</a> is made and is ignored in subsequent calls if given. If the first call is made without giving the <i>options</i> parameter, then the context and render target is initialized with default configuration.</p>
<p><b>See also </b><a href="qml-qtcanvas3d-canvas3dcontextattributes.html">Canvas3DContextAttributes</a>, <a href="qml-qtcanvas3d-context3d.html">Context3D</a>, and <a href="qml-qtcanvas3d-canvas3d.html#renderTarget-prop">renderTarget</a>.</p>
</div></div><!-- @@@getContext -->
<br/>
<!-- $$$getContext -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="getContext-method">
<td class="tblQmlFuncNode"><p>
<a name="getContext-method"></a><span class="type"><a href="qml-qtcanvas3d-context3d.html">Context3D</a></span> <span class="name">getContext</span>(<span class="type">string</span> <i>type</i>)</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Returns the 3D rendering context that allows 3D rendering calls to be made. The <i>type</i> parameter is ignored for now, but a string is expected to be given.</p>
</div></div><!-- @@@getContext -->
<br/>
<!-- $$$requestRender -->
<div class="qmlitem"><div class="qmlproto">
<div class="table"><table class="qmlname">
<tr valign="top" class="odd" id="requestRender-method">
<td class="tblQmlFuncNode"><p>
<a name="requestRender-method"></a><span class="type">void</span> <span class="name">requestRender</span>()</p></td></tr>
</table></div>
</div><div class="qmldoc"><p>Queues a new frame for rendering when <a href="qml-qtcanvas3d-canvas3d.html#renderOnDemand-prop">Canvas3D.renderOnDemand</a> property is <code>true</code>. Does nothing when <a href="qml-qtcanvas3d-canvas3d.html#renderOnDemand-prop">Canvas3D.renderOnDemand</a> property is <code>false</code>.</p>
</div></div><!-- @@@requestRender -->
<br/>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2016 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
