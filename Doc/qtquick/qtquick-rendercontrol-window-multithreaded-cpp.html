<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>window_multithreaded.cpp Example File | Qt Quick 5.7</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    window.onload = function(){document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");};
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/supported-platforms-and-configurations.html#qt-5-7">Qt 5.7</a></td><td ><a href="qtquick-index.html">Qt Quick</a></td><td ><a href="qtquick-rendercontrol-example.html">QQuickRenderControl Example</a></td><td >window_multithreaded.cpp Example File</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right">Qt 5.7.0 Reference Documentation</td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar"><div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">window_multithreaded.cpp Example File</h1>
<span class="subtitle">rendercontrol/window_multithreaded.cpp</span>
<!-- $$$rendercontrol/window_multithreaded.cpp-description -->
<div class="descr"> <a name="details"></a>
<pre class="cpp">

  <span class="comment">/****************************************************************************
  **
  ** Copyright (C) 2015 The Qt Company Ltd.
  ** Contact: http://www.qt.io/licensing/
  **
  ** This file is part of the examples of the Qt Toolkit.
  **
  ** $QT_BEGIN_LICENSE:BSD$
  ** You may use this file under the terms of the BSD license as follows:
  **
  ** &quot;Redistribution and use in source and binary forms, with or without
  ** modification, are permitted provided that the following conditions are
  ** met:
  **   * Redistributions of source code must retain the above copyright
  **     notice, this list of conditions and the following disclaimer.
  **   * Redistributions in binary form must reproduce the above copyright
  **     notice, this list of conditions and the following disclaimer in
  **     the documentation and/or other materials provided with the
  **     distribution.
  **   * Neither the name of The Qt Company Ltd nor the names of its
  **     contributors may be used to endorse or promote products derived
  **     from this software without specific prior written permission.
  **
  **
  ** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  ** &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  ** LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  ** A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  ** OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  ** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  ** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;
  **
  ** $QT_END_LICENSE$
  **
  ****************************************************************************/</span>

  <span class="preprocessor">#include &quot;window_multithreaded.h&quot;</span>
  <span class="preprocessor">#include &quot;cuberenderer.h&quot;</span>
  <span class="preprocessor">#include &lt;QOpenGLContext&gt;</span>
  <span class="preprocessor">#include &lt;QOpenGLFunctions&gt;</span>
  <span class="preprocessor">#include &lt;QOpenGLFramebufferObject&gt;</span>
  <span class="preprocessor">#include &lt;QOpenGLShaderProgram&gt;</span>
  <span class="preprocessor">#include &lt;QOpenGLVertexArrayObject&gt;</span>
  <span class="preprocessor">#include &lt;QOpenGLBuffer&gt;</span>
  <span class="preprocessor">#include &lt;QOpenGLVertexArrayObject&gt;</span>
  <span class="preprocessor">#include &lt;QOffscreenSurface&gt;</span>
  <span class="preprocessor">#include &lt;QQmlEngine&gt;</span>
  <span class="preprocessor">#include &lt;QQmlComponent&gt;</span>
  <span class="preprocessor">#include &lt;QQuickItem&gt;</span>
  <span class="preprocessor">#include &lt;QQuickWindow&gt;</span>
  <span class="preprocessor">#include &lt;QQuickRenderControl&gt;</span>
  <span class="preprocessor">#include &lt;QCoreApplication&gt;</span>

  <span class="comment">/*
    This implementation runs the Qt Quick scenegraph's sync and render phases on a
    separate, dedicated thread.  Rendering the cube using our custom OpenGL engine
    happens on that thread as well.  This is similar to the built-in threaded
    render loop, but does not support all the features. There is no support for
    getting Animators running on the render thread for example.

    We choose to use QObject's event mechanism to communicate with the QObject
    living on the render thread. An alternative would be to subclass QThread and
    reimplement run() with a custom event handling approach, like
    QSGThreadedRenderLoop does. That would potentially lead to better results but
    is also more complex.
  */</span>

  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type INIT <span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>User <span class="operator">+</span> <span class="number">1</span>);
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type RENDER <span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>User <span class="operator">+</span> <span class="number">2</span>);
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type RESIZE <span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>User <span class="operator">+</span> <span class="number">3</span>);
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type STOP <span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>User <span class="operator">+</span> <span class="number">4</span>);

  <span class="keyword">static</span> <span class="keyword">const</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type UPDATE <span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Type(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>User <span class="operator">+</span> <span class="number">5</span>);

  QuickRenderer<span class="operator">::</span>QuickRenderer()
      : m_context(<span class="number">0</span>)<span class="operator">,</span>
        m_surface(<span class="number">0</span>)<span class="operator">,</span>
        m_fbo(<span class="number">0</span>)<span class="operator">,</span>
        m_window(<span class="number">0</span>)<span class="operator">,</span>
        m_quickWindow(<span class="number">0</span>)<span class="operator">,</span>
        m_renderControl(<span class="number">0</span>)<span class="operator">,</span>
        m_cubeRenderer(<span class="number">0</span>)<span class="operator">,</span>
        m_quit(<span class="keyword">false</span>)
  {
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>requestInit()
  {
      <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>postEvent(<span class="keyword">this</span><span class="operator">,</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span>(INIT));
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>requestRender()
  {
      <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>postEvent(<span class="keyword">this</span><span class="operator">,</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span>(RENDER));
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>requestResize()
  {
      <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>postEvent(<span class="keyword">this</span><span class="operator">,</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span>(RESIZE));
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>requestStop()
  {
      <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>postEvent(<span class="keyword">this</span><span class="operator">,</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span>(STOP));
  }

  bool QuickRenderer<span class="operator">::</span>event(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> <span class="operator">*</span>e)
  {
      <span class="type"><a href="../qtcore/qmutexlocker.html">QMutexLocker</a></span> lock(<span class="operator">&amp;</span>m_mutex);

      <span class="keyword">switch</span> (<span class="type">int</span>(e<span class="operator">-</span><span class="operator">&gt;</span>type())) {
      <span class="keyword">case</span> INIT:
          init();
          <span class="keyword">return</span> <span class="keyword">true</span>;
      <span class="keyword">case</span> RENDER:
          render(<span class="operator">&amp;</span>lock);
          <span class="keyword">return</span> <span class="keyword">true</span>;
      <span class="keyword">case</span> RESIZE:
          <span class="keyword">if</span> (m_cubeRenderer)
              m_cubeRenderer<span class="operator">-</span><span class="operator">&gt;</span>resize(m_window<span class="operator">-</span><span class="operator">&gt;</span>width()<span class="operator">,</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>height());
          <span class="keyword">return</span> <span class="keyword">true</span>;
      <span class="keyword">case</span> STOP:
          cleanup();
          <span class="keyword">return</span> <span class="keyword">true</span>;
      <span class="keyword">default</span>:
          <span class="keyword">return</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span><span class="operator">::</span>event(e);
      }
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>init()
  {
      m_context<span class="operator">-</span><span class="operator">&gt;</span>makeCurrent(m_surface);

      <span class="comment">// Pass our offscreen surface to the cube renderer just so that it will</span>
      <span class="comment">// have something is can make current during cleanup. QOffscreenSurface,</span>
      <span class="comment">// just like QWindow, must always be created on the gui thread (as it might</span>
      <span class="comment">// be backed by an actual QWindow).</span>
      m_cubeRenderer <span class="operator">=</span> <span class="keyword">new</span> CubeRenderer(m_surface);
      m_cubeRenderer<span class="operator">-</span><span class="operator">&gt;</span>resize(m_window<span class="operator">-</span><span class="operator">&gt;</span>width()<span class="operator">,</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>height());

      m_renderControl<span class="operator">-</span><span class="operator">&gt;</span>initialize(m_context);
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>cleanup()
  {
      m_context<span class="operator">-</span><span class="operator">&gt;</span>makeCurrent(m_surface);

      m_renderControl<span class="operator">-</span><span class="operator">&gt;</span>invalidate();

      <span class="keyword">delete</span> m_fbo;
      m_fbo <span class="operator">=</span> <span class="number">0</span>;

      <span class="keyword">delete</span> m_cubeRenderer;
      m_cubeRenderer <span class="operator">=</span> <span class="number">0</span>;

      m_context<span class="operator">-</span><span class="operator">&gt;</span>doneCurrent();
      m_context<span class="operator">-</span><span class="operator">&gt;</span>moveToThread(<span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>instance()<span class="operator">-</span><span class="operator">&gt;</span>thread());

      m_cond<span class="operator">.</span>wakeOne();
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>ensureFbo()
  {
      <span class="keyword">if</span> (m_fbo <span class="operator">&amp;</span><span class="operator">&amp;</span> m_fbo<span class="operator">-</span><span class="operator">&gt;</span>size() <span class="operator">!</span><span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>size() <span class="operator">*</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>devicePixelRatio()) {
          <span class="keyword">delete</span> m_fbo;
          m_fbo <span class="operator">=</span> <span class="number">0</span>;
      }

      <span class="keyword">if</span> (<span class="operator">!</span>m_fbo) {
          m_fbo <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a></span>(m_window<span class="operator">-</span><span class="operator">&gt;</span>size() <span class="operator">*</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>devicePixelRatio()<span class="operator">,</span>
                                               <span class="type"><a href="../qtgui/qopenglframebufferobject.html">QOpenGLFramebufferObject</a></span><span class="operator">::</span>CombinedDepthStencil);
          m_quickWindow<span class="operator">-</span><span class="operator">&gt;</span>setRenderTarget(m_fbo);
      }
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>render(<span class="type"><a href="../qtcore/qmutexlocker.html">QMutexLocker</a></span> <span class="operator">*</span>lock)
  {
      Q_ASSERT(<span class="type"><a href="../qtcore/qthread.html">QThread</a></span><span class="operator">::</span>currentThread() <span class="operator">!</span><span class="operator">=</span> m_window<span class="operator">-</span><span class="operator">&gt;</span>thread());

      <span class="keyword">if</span> (<span class="operator">!</span>m_context<span class="operator">-</span><span class="operator">&gt;</span>makeCurrent(m_surface)) {
          <a href="../qtcore/qtglobal.html#qWarning">qWarning</a>(<span class="string">&quot;Failed to make context current on render thread&quot;</span>);
          <span class="keyword">return</span>;
      }

      ensureFbo();

      <span class="comment">// Synchronization and rendering happens here on the render thread.</span>
      m_renderControl<span class="operator">-</span><span class="operator">&gt;</span>sync();

      <span class="comment">// The gui thread can now continue.</span>
      m_cond<span class="operator">.</span>wakeOne();
      lock<span class="operator">-</span><span class="operator">&gt;</span>unlock();

      <span class="comment">// Meanwhile on this thread continue with the actual rendering (into the FBO first).</span>
      m_renderControl<span class="operator">-</span><span class="operator">&gt;</span>render();
      m_context<span class="operator">-</span><span class="operator">&gt;</span>functions()<span class="operator">-</span><span class="operator">&gt;</span>glFlush();

      <span class="comment">// The cube renderer uses its own context, no need to bother with the state here.</span>

      <span class="comment">// Get something onto the screen using our custom OpenGL engine.</span>
      <span class="type"><a href="../qtcore/qmutexlocker.html">QMutexLocker</a></span> quitLock(<span class="operator">&amp;</span>m_quitMutex);
      <span class="keyword">if</span> (<span class="operator">!</span>m_quit)
          m_cubeRenderer<span class="operator">-</span><span class="operator">&gt;</span>render(m_window<span class="operator">,</span> m_context<span class="operator">,</span> m_fbo<span class="operator">-</span><span class="operator">&gt;</span>texture());
  }

  <span class="type">void</span> QuickRenderer<span class="operator">::</span>aboutToQuit()
  {
      <span class="type"><a href="../qtcore/qmutexlocker.html">QMutexLocker</a></span> lock(<span class="operator">&amp;</span>m_quitMutex);
      m_quit <span class="operator">=</span> <span class="keyword">true</span>;
  }

  <span class="keyword">class</span> RenderControl : <span class="keyword">public</span> <span class="type"><a href="qquickrendercontrol.html">QQuickRenderControl</a></span>
  {
  <span class="keyword">public</span>:
      RenderControl(<span class="type"><a href="../qtgui/qwindow.html">QWindow</a></span> <span class="operator">*</span>w) : m_window(w) { }
      <span class="type"><a href="../qtgui/qwindow.html">QWindow</a></span> <span class="operator">*</span>renderWindow(<span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> <span class="operator">*</span>offset) Q_DECL_OVERRIDE;

  <span class="keyword">private</span>:
      <span class="type"><a href="../qtgui/qwindow.html">QWindow</a></span> <span class="operator">*</span>m_window;
  };

  WindowMultiThreaded<span class="operator">::</span>WindowMultiThreaded()
      : m_qmlComponent(Q_NULLPTR)<span class="operator">,</span>
        m_rootItem(<span class="number">0</span>)<span class="operator">,</span>
        m_quickInitialized(<span class="keyword">false</span>)<span class="operator">,</span>
        m_psrRequested(<span class="keyword">false</span>)
  {
      setSurfaceType(<span class="type"><a href="../qtgui/qsurface.html">QSurface</a></span><span class="operator">::</span>OpenGLSurface);

      <span class="type"><a href="../qtgui/qsurfaceformat.html">QSurfaceFormat</a></span> format;
      <span class="comment">// Qt Quick may need a depth and stencil buffer. Always make sure these are available.</span>
      format<span class="operator">.</span>setDepthBufferSize(<span class="number">16</span>);
      format<span class="operator">.</span>setStencilBufferSize(<span class="number">8</span>);
      setFormat(format);

      m_context <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtgui/qopenglcontext.html">QOpenGLContext</a></span>;
      m_context<span class="operator">-</span><span class="operator">&gt;</span>setFormat(format);
      m_context<span class="operator">-</span><span class="operator">&gt;</span>create();

      m_offscreenSurface <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtgui/qoffscreensurface.html">QOffscreenSurface</a></span>;
      <span class="comment">// Pass m_context-&gt;format(), not format. Format does not specify and color buffer</span>
      <span class="comment">// sizes, while the context, that has just been created, reports a format that has</span>
      <span class="comment">// these values filled in. Pass this to the offscreen surface to make sure it will be</span>
      <span class="comment">// compatible with the context's configuration.</span>
      m_offscreenSurface<span class="operator">-</span><span class="operator">&gt;</span>setFormat(m_context<span class="operator">-</span><span class="operator">&gt;</span>format());
      m_offscreenSurface<span class="operator">-</span><span class="operator">&gt;</span>create();

      m_renderControl <span class="operator">=</span> <span class="keyword">new</span> RenderControl(<span class="keyword">this</span>);

      <span class="comment">// Create a QQuickWindow that is associated with out render control. Note that this</span>
      <span class="comment">// window never gets created or shown, meaning that it will never get an underlying</span>
      <span class="comment">// native (platform) window.</span>
      m_quickWindow <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qquickwindow.html">QQuickWindow</a></span>(m_renderControl);

      <span class="comment">// Create a QML engine.</span>
      m_qmlEngine <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtqml/qqmlengine.html">QQmlEngine</a></span>;
      <span class="keyword">if</span> (<span class="operator">!</span>m_qmlEngine<span class="operator">-</span><span class="operator">&gt;</span>incubationController())
          m_qmlEngine<span class="operator">-</span><span class="operator">&gt;</span>setIncubationController(m_quickWindow<span class="operator">-</span><span class="operator">&gt;</span>incubationController());

      m_quickRenderer <span class="operator">=</span> <span class="keyword">new</span> QuickRenderer;
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>setContext(m_context);

      <span class="comment">// These live on the gui thread. Just give access to them on the render thread.</span>
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>setSurface(m_offscreenSurface);
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>setWindow(<span class="keyword">this</span>);
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>setQuickWindow(m_quickWindow);
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>setRenderControl(m_renderControl);

      m_quickRendererThread <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qthread.html">QThread</a></span>;

      <span class="comment">// Notify the render control that some scenegraph internals have to live on</span>
      <span class="comment">// m_quickRenderThread.</span>
      m_renderControl<span class="operator">-</span><span class="operator">&gt;</span>prepareThread(m_quickRendererThread);

      <span class="comment">// The QOpenGLContext and the QObject representing the rendering logic on</span>
      <span class="comment">// the render thread must live on that thread.</span>
      m_context<span class="operator">-</span><span class="operator">&gt;</span>moveToThread(m_quickRendererThread);
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>moveToThread(m_quickRendererThread);

      m_quickRendererThread<span class="operator">-</span><span class="operator">&gt;</span>start();

      <span class="comment">// Now hook up the signals. For simplicy we don't differentiate</span>
      <span class="comment">// between renderRequested (only render is needed, no sync) and</span>
      <span class="comment">// sceneChanged (polish and sync is needed too).</span>
      connect(m_renderControl<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qquickrendercontrol.html">QQuickRenderControl</a></span><span class="operator">::</span>renderRequested<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>WindowMultiThreaded<span class="operator">::</span>requestUpdate);
      connect(m_renderControl<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="qquickrendercontrol.html">QQuickRenderControl</a></span><span class="operator">::</span>sceneChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>WindowMultiThreaded<span class="operator">::</span>requestUpdate);
  }

  WindowMultiThreaded<span class="operator">::</span><span class="operator">~</span>WindowMultiThreaded()
  {
      <span class="comment">// Release resources and move the context ownership back to this thread.</span>
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>mutex()<span class="operator">-</span><span class="operator">&gt;</span>lock();
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>requestStop();
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span><span class="type">cond</span>()<span class="operator">-</span><span class="operator">&gt;</span>wait(m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>mutex());
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>mutex()<span class="operator">-</span><span class="operator">&gt;</span>unlock();

      m_quickRendererThread<span class="operator">-</span><span class="operator">&gt;</span>quit();
      m_quickRendererThread<span class="operator">-</span><span class="operator">&gt;</span>wait();

      <span class="keyword">delete</span> m_renderControl;
      <span class="keyword">delete</span> m_qmlComponent;
      <span class="keyword">delete</span> m_quickWindow;
      <span class="keyword">delete</span> m_qmlEngine;

      <span class="keyword">delete</span> m_offscreenSurface;
      <span class="keyword">delete</span> m_context;
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>requestUpdate()
  {
      <span class="keyword">if</span> (m_quickInitialized <span class="operator">&amp;</span><span class="operator">&amp;</span> <span class="operator">!</span>m_psrRequested) {
          m_psrRequested <span class="operator">=</span> <span class="keyword">true</span>;
          <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>postEvent(<span class="keyword">this</span><span class="operator">,</span> <span class="keyword">new</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span>(UPDATE));
      }
  }

  bool WindowMultiThreaded<span class="operator">::</span>event(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> <span class="operator">*</span>e)
  {
      <span class="keyword">if</span> (e<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> UPDATE) {
          polishSyncAndRender();
          m_psrRequested <span class="operator">=</span> <span class="keyword">false</span>;
          <span class="keyword">return</span> <span class="keyword">true</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (e<span class="operator">-</span><span class="operator">&gt;</span>type() <span class="operator">=</span><span class="operator">=</span> <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span><span class="operator">::</span>Close) {
          <span class="comment">// Avoid rendering on the render thread when the window is about to</span>
          <span class="comment">// close. Once a QWindow is closed, the underlying platform window will</span>
          <span class="comment">// go away, even though the QWindow instance itself is still</span>
          <span class="comment">// valid. Operations like swapBuffers() are futile and only result in</span>
          <span class="comment">// warnings afterwards. Prevent this.</span>
          m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>aboutToQuit();
      }
      <span class="keyword">return</span> <span class="type"><a href="../qtgui/qwindow.html">QWindow</a></span><span class="operator">::</span>event(e);
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>polishSyncAndRender()
  {
      Q_ASSERT(<span class="type"><a href="../qtcore/qthread.html">QThread</a></span><span class="operator">::</span>currentThread() <span class="operator">=</span><span class="operator">=</span> thread());

      <span class="comment">// Polishing happens on the gui thread.</span>
      m_renderControl<span class="operator">-</span><span class="operator">&gt;</span>polishItems();
      <span class="comment">// Sync happens on the render thread with the gui thread (this one) blocked.</span>
      <span class="type"><a href="../qtcore/qmutexlocker.html">QMutexLocker</a></span> lock(m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>mutex());
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>requestRender();
      <span class="comment">// Wait until sync is complete.</span>
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span><span class="type">cond</span>()<span class="operator">-</span><span class="operator">&gt;</span>wait(m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>mutex());
      <span class="comment">// Rendering happens on the render thread without blocking the gui (main)</span>
      <span class="comment">// thread. This is good because the blocking swap (waiting for vsync)</span>
      <span class="comment">// happens on the render thread, not blocking other work.</span>
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>run()
  {
      disconnect(m_qmlComponent<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtqml/qqmlcomponent.html">QQmlComponent</a></span><span class="operator">::</span>statusChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>WindowMultiThreaded<span class="operator">::</span>run);

      <span class="keyword">if</span> (m_qmlComponent<span class="operator">-</span><span class="operator">&gt;</span>isError()) {
          <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtqml/qqmlerror.html">QQmlError</a></span><span class="operator">&gt;</span> errorList <span class="operator">=</span> m_qmlComponent<span class="operator">-</span><span class="operator">&gt;</span>errors();
          foreach (<span class="keyword">const</span> <span class="type"><a href="../qtqml/qqmlerror.html">QQmlError</a></span> <span class="operator">&amp;</span>error<span class="operator">,</span> errorList)
              <a href="../qtcore/qtglobal.html#qWarning">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> error<span class="operator">.</span>url() <span class="operator">&lt;</span><span class="operator">&lt;</span> error<span class="operator">.</span>line() <span class="operator">&lt;</span><span class="operator">&lt;</span> error;
          <span class="keyword">return</span>;
      }

      <span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span>rootObject <span class="operator">=</span> m_qmlComponent<span class="operator">-</span><span class="operator">&gt;</span>create();
      <span class="keyword">if</span> (m_qmlComponent<span class="operator">-</span><span class="operator">&gt;</span>isError()) {
          <span class="type"><a href="../qtcore/qlist.html">QList</a></span><span class="operator">&lt;</span><span class="type"><a href="../qtqml/qqmlerror.html">QQmlError</a></span><span class="operator">&gt;</span> errorList <span class="operator">=</span> m_qmlComponent<span class="operator">-</span><span class="operator">&gt;</span>errors();
          foreach (<span class="keyword">const</span> <span class="type"><a href="../qtqml/qqmlerror.html">QQmlError</a></span> <span class="operator">&amp;</span>error<span class="operator">,</span> errorList)
              <a href="../qtcore/qtglobal.html#qWarning">qWarning</a>() <span class="operator">&lt;</span><span class="operator">&lt;</span> error<span class="operator">.</span>url() <span class="operator">&lt;</span><span class="operator">&lt;</span> error<span class="operator">.</span>line() <span class="operator">&lt;</span><span class="operator">&lt;</span> error;
          <span class="keyword">return</span>;
      }

      m_rootItem <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="qquickitem.html">QQuickItem</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(rootObject);
      <span class="keyword">if</span> (<span class="operator">!</span>m_rootItem) {
          <a href="../qtcore/qtglobal.html#qWarning">qWarning</a>(<span class="string">&quot;run: Not a QQuickItem&quot;</span>);
          <span class="keyword">delete</span> rootObject;
          <span class="keyword">return</span>;
      }

      <span class="comment">// The root item is ready. Associate it with the window.</span>
      m_rootItem<span class="operator">-</span><span class="operator">&gt;</span>setParentItem(m_quickWindow<span class="operator">-</span><span class="operator">&gt;</span>contentItem());

      <span class="comment">// Update item and rendering related geometries.</span>
      updateSizes();

      m_quickInitialized <span class="operator">=</span> <span class="keyword">true</span>;

      <span class="comment">// Initialize the render thread and perform the first polish/sync/render.</span>
      m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>requestInit();
      polishSyncAndRender();
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>updateSizes()
  {
      <span class="comment">// Behave like SizeRootObjectToView.</span>
      m_rootItem<span class="operator">-</span><span class="operator">&gt;</span>setWidth(width());
      m_rootItem<span class="operator">-</span><span class="operator">&gt;</span>setHeight(height());

      m_quickWindow<span class="operator">-</span><span class="operator">&gt;</span>setGeometry(<span class="number">0</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> width()<span class="operator">,</span> height());
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>startQuick(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span> <span class="operator">&amp;</span>filename)
  {
      m_qmlComponent <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="../qtqml/qqmlcomponent.html">QQmlComponent</a></span>(m_qmlEngine<span class="operator">,</span> <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span>(filename));
      <span class="keyword">if</span> (m_qmlComponent<span class="operator">-</span><span class="operator">&gt;</span>isLoading())
          connect(m_qmlComponent<span class="operator">,</span> <span class="operator">&amp;</span><span class="type"><a href="../qtqml/qqmlcomponent.html">QQmlComponent</a></span><span class="operator">::</span>statusChanged<span class="operator">,</span> <span class="keyword">this</span><span class="operator">,</span> <span class="operator">&amp;</span>WindowMultiThreaded<span class="operator">::</span>run);
      <span class="keyword">else</span>
          run();
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>exposeEvent(<span class="type"><a href="../qtgui/qexposeevent.html">QExposeEvent</a></span> <span class="operator">*</span>)
  {
      <span class="keyword">if</span> (isExposed()) {
          <span class="keyword">if</span> (<span class="operator">!</span>m_quickInitialized)
              startQuick(<span class="type"><a href="../qtcore/qstring.html#QStringLiteral">QStringLiteral</a></span>(<span class="string">&quot;qrc:/rendercontrol/demo.qml&quot;</span>));
      }
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>resizeEvent(<span class="type"><a href="../qtgui/qresizeevent.html">QResizeEvent</a></span> <span class="operator">*</span>)
  {
      <span class="comment">// If this is a resize after the scene is up and running, recreate the fbo and the</span>
      <span class="comment">// Quick item and scene.</span>
      <span class="keyword">if</span> (m_rootItem) {
          updateSizes();
          m_quickRenderer<span class="operator">-</span><span class="operator">&gt;</span>requestResize();
          polishSyncAndRender();
      }
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>mousePressEvent(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> <span class="operator">*</span>e)
  {
      <span class="comment">// Use the constructor taking localPos and screenPos. That puts localPos into the</span>
      <span class="comment">// event's localPos and windowPos, and screenPos into the event's screenPos. This way</span>
      <span class="comment">// the windowPos in e is ignored and is replaced by localPos. This is necessary</span>
      <span class="comment">// because QQuickWindow thinks of itself as a top-level window always.</span>
      <span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> mappedEvent(e<span class="operator">-</span><span class="operator">&gt;</span>type()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>localPos()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>screenPos()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>button()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>buttons()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>modifiers());
      <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>sendEvent(m_quickWindow<span class="operator">,</span> <span class="operator">&amp;</span>mappedEvent);
  }

  <span class="type">void</span> WindowMultiThreaded<span class="operator">::</span>mouseReleaseEvent(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> <span class="operator">*</span>e)
  {
      <span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> mappedEvent(e<span class="operator">-</span><span class="operator">&gt;</span>type()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>localPos()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>screenPos()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>button()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>buttons()<span class="operator">,</span> e<span class="operator">-</span><span class="operator">&gt;</span>modifiers());
      <span class="type"><a href="../qtcore/qcoreapplication.html">QCoreApplication</a></span><span class="operator">::</span>sendEvent(m_quickWindow<span class="operator">,</span> <span class="operator">&amp;</span>mappedEvent);
  }

</pre>
</div>
<!-- @@@rendercontrol/window_multithreaded.cpp -->
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2016 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
